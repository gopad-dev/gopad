package cursor

import (
	"context"
	"errors"
	"log"
	"time"

	"github.com/charmbracelet/bubbletea/v2"
	"github.com/charmbracelet/lipgloss"
)

const DefaultBlinkInterval = time.Millisecond * 530

// initialBlinkMsg initializes cursor blinking.
type initialBlinkMsg struct{}

// BlinkMsg signals that the cursor should blink. It contains metadata that
// allows us to tell if the blink message is the one we're expecting.
type BlinkMsg struct {
	id  int
	tag int
}

// blinkCanceled is sent when a blink operation is canceled.
type blinkCanceled struct{}

// blinkCtx manages cursor blinking.
type blinkCtx struct {
	ctx    context.Context
	cancel context.CancelFunc
}

// Mode describes the behavior of the cursor.
type Mode int

// Available cursor modes.
const (
	ModeBlink Mode = iota
	ModeStatic
	ModeHide
)

var modeNames = map[Mode]string{
	ModeBlink:  "blink",
	ModeStatic: "static",
	ModeHide:   "hidden",
}

// String returns the cursor mode in a human-readable format. This method is
// provisional and for informational purposes only.
func (c Mode) String() string {
	return modeNames[c]
}

func (c *Mode) UnmarshalText(text []byte) error {
	for k, v := range modeNames {
		if v == string(text) {
			*c = k
			return nil
		}
	}
	return errors.New("invalid cursor mode")
}

func (c Mode) MarshalText() ([]byte, error) {
	return []byte(c.String()), nil
}

type Shape int

const (
	ShapeBlock Shape = iota
	ShapeUnderline
)

var shapeNames = map[Shape]string{
	ShapeBlock:     "block",
	ShapeUnderline: "underline",
}

func (s Shape) String() string {
	return shapeNames[s]
}

func (s *Shape) UnmarshalText(text []byte) error {
	for k, v := range shapeNames {
		if v == string(text) {
			*s = k
			return nil
		}
	}
	return errors.New("invalid cursor style")
}

func (s Shape) MarshalText() ([]byte, error) {
	return []byte(s.String()), nil
}

type Styles struct {
	// Style for styling the cursor block.
	BlockCursor lipgloss.Style
	// Style for styling the cursor underline.
	UnderlineCursor lipgloss.Style
}

var DefaultStyles = Styles{
	BlockCursor:     lipgloss.NewStyle().Background(lipgloss.Color("205")).Reverse(true),
	UnderlineCursor: lipgloss.NewStyle().Underline(true),
}

// Model is the Bubble Tea model for this cursor element.
type Model struct {
	Styles        Styles
	BlinkInterval time.Duration
	Shape         Shape
	// mode determines the behavior of the cursor
	mode Mode

	// The ID of this Model as it relates to other cursors
	id int
	// focus indicates whether the containing input is focused
	focus bool
	Blink bool
	// Used to manage cursor blink
	blinkCtx *blinkCtx
	// The ID of the blink message we're expecting to receive.
	blinkTag int
}

// New creates a new model with default settings.
func New() Model {
	return Model{
		BlinkInterval: DefaultBlinkInterval,
		Styles:        DefaultStyles,

		Blink: true,
		mode:  ModeBlink,

		blinkCtx: &blinkCtx{
			ctx: context.Background(),
		},
	}
}

// Update updates the cursor.
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
	switch msg := msg.(type) {
	case initialBlinkMsg:
		// We accept all initialBlinkMsgs generated by the Blink command.

		if m.mode != ModeBlink || !m.focus {
			return m, nil
		}

		cmd := m.BlinkCmd()
		return m, cmd

	case BlinkMsg:
		// We're choosy about whether to accept blinkMsgs so that our cursor
		// only gopadctly when it should.

		// Is this model blink-able?
		if m.mode != ModeBlink || !m.focus {
			return m, nil
		}

		// Were we expecting this blink message?
		if msg.id != m.id || msg.tag != m.blinkTag {
			return m, nil
		}

		var cmd tea.Cmd
		if m.mode == ModeBlink {
			m.Blink = !m.Blink
			cmd = m.BlinkCmd()
		}
		return m, cmd

	case blinkCanceled: // no-op
		return m, nil
	}
	return m, nil
}

// Mode returns the model's cursor mode. For available cursor modes, see
// type Mode.
func (m Model) Mode() Mode {
	return m.mode
}

// SetMode sets the model's cursor mode. This method returns a command.
//
// For available cursor modes, see type CursorMode.
func (m *Model) SetMode(mode Mode) tea.Cmd {
	m.mode = mode
	m.Blink = m.mode == ModeHide || !m.focus
	if mode == ModeBlink {
		return Blink
	}
	return nil
}

// BlinkCmd is a command used to manage cursor blinking.
func (m *Model) BlinkCmd() tea.Cmd {
	if m.mode != ModeBlink {
		return nil
	}

	if m.blinkCtx != nil && m.blinkCtx.cancel != nil {
		m.blinkCtx.cancel()
	}

	if m.blinkCtx == nil {
		log.Println("blinkCtx is nil")
		m.blinkCtx = &blinkCtx{
			ctx: context.Background(),
		}
	}

	ctx, cancel := context.WithTimeout(m.blinkCtx.ctx, m.BlinkInterval)
	m.blinkCtx.cancel = cancel

	m.blinkTag++

	return func() tea.Msg {
		defer cancel()
		<-ctx.Done()
		if errors.Is(ctx.Err(), context.DeadlineExceeded) {
			return BlinkMsg{id: m.id, tag: m.blinkTag}
		}
		return blinkCanceled{}
	}
}

// Blink is a command used to initialize cursor blinking.
func Blink() tea.Msg {
	return initialBlinkMsg{}
}

// Focus focuses the cursor to allow it to blink if desired.
func (m *Model) Focus() tea.Cmd {
	m.focus = true
	m.Blink = m.mode == ModeHide // show the cursor unless we've explicitly hidden it

	if m.mode == ModeBlink && m.focus {
		return m.BlinkCmd()
	}
	return nil
}

// Blur blurs the cursor.
func (m *Model) Blur() {
	m.focus = false
	m.Blink = true
}

// Focused returns whether the cursor is focused.
func (m Model) Focused() bool {
	return m.focus
}

// View displays the cursor.
func (m Model) View(char string, textStyle lipgloss.Style) string {
	if m.Blink {
		return textStyle.Render(char)
	}

	var style lipgloss.Style
	switch m.Shape {
	case ShapeBlock:
		style = m.Styles.BlockCursor
	case ShapeUnderline:
		style = m.Styles.UnderlineCursor.Inherit(textStyle)
	}

	return style.Render(char)
}
